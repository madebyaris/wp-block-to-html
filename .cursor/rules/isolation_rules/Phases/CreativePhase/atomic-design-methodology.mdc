---
description: Atomic design methodology rules for systematic component design
globs: "**/design*/**", "**/ui*/**", "**/ux*/**", "**/component*/**"
alwaysApply: false
---

# ATOMIC DESIGN METHODOLOGY FOR ENHANCED DESIGN MODE

> **TL;DR:** This document provides comprehensive rules for implementing atomic design methodology in the enhanced design mode, ensuring systematic component development from design tokens to complete user interfaces.

## ‚öõÔ∏è ATOMIC DESIGN HIERARCHY OVERVIEW

### The Five Levels of Atomic Design
```mermaid
graph TD
    DesignTokens["üé® DESIGN TOKENS<br>Colors, Typography, Spacing, Elevation"] --> Atoms["‚öõÔ∏è ATOMS<br>Basic UI Elements"]
    Atoms --> Molecules["üß¨ MOLECULES<br>Simple Component Groups"]
    Molecules --> Organisms["ü¶† ORGANISMS<br>Complex UI Sections"]
    Organisms --> Templates["üìã TEMPLATES<br>Page-Level Structures"]
    Templates --> Pages["üìÑ PAGES<br>Complete User Interfaces"]
    
    %% Cross-cutting concerns
    DesignTokens -.-> Responsive["üì± RESPONSIVE BEHAVIOR<br>Applied at all levels"]
    DesignTokens -.-> Accessibility["‚ôø ACCESSIBILITY<br>Integrated throughout"]
    DesignTokens -.-> Performance["‚ö° PERFORMANCE<br>Optimized at each level"]
    
    style DesignTokens fill:#ffeb3b,stroke:#f57c00,color:black
    style Atoms fill:#4caf50,stroke:#2e7d32,color:white
    style Molecules fill:#2196f3,stroke:#1565c0,color:white
    style Organisms fill:#ff9800,stroke:#ef6c00,color:white
    style Templates fill:#9c27b0,stroke:#6a1b99,color:white
    style Pages fill:#f44336,stroke:#c62828,color:white
    style Responsive fill:#795548,stroke:#5d4037,color:white
    style Accessibility fill:#607d8b,stroke:#455a64,color:white
    style Performance fill:#009688,stroke:#00695c,color:white
```

## üé® DESIGN TOKENS (FOUNDATION LEVEL)

### Design Token Categories
Design tokens are the foundational elements that ensure consistency across all atomic levels:

#### Color Tokens
```markdown
‚úÖ COLOR TOKEN REQUIREMENTS
‚ñ° Primary color palette with accessibility-compliant variations
‚ñ° Secondary and accent color systems
‚ñ° Semantic color tokens (success, warning, error, info)
‚ñ° Neutral color scale (grays) with sufficient contrast ratios
‚ñ° Dark mode and high contrast variants
‚ñ° Platform-specific color adaptations (iOS Dynamic Colors, Material You)
‚ñ° WCAG AAA contrast ratios verified (7:1 for normal text, 4.5:1 for large text)
```

#### Typography Tokens
```markdown
‚úÖ TYPOGRAPHY TOKEN REQUIREMENTS
‚ñ° Font family hierarchy (primary, secondary, monospace)
‚ñ° Font size scale with fluid typography support
‚ñ° Font weight variations (light, regular, medium, semibold, bold)
‚ñ° Line height system for optimal readability
‚ñ° Letter spacing adjustments for different sizes
‚ñ° Platform-specific typography (San Francisco for iOS, Roboto for Android)
‚ñ° Dynamic Type support (iOS) and font scaling (Android)
‚ñ° Accessibility considerations (minimum 16px base size)
```

#### Spacing Tokens
```markdown
‚úÖ SPACING TOKEN REQUIREMENTS
‚ñ° Base spacing unit (typically 4px or 8px)
‚ñ° Spacing scale (0.25x, 0.5x, 1x, 1.5x, 2x, 3x, 4x, 6x, 8x)
‚ñ° Component-specific spacing (padding, margin, gap)
‚ñ° Touch target spacing (minimum 8px between interactive elements)
‚ñ° Platform-specific spacing adaptations
‚ñ° Responsive spacing adjustments
‚ñ° Accessibility spacing requirements
```

#### Elevation and Shadow Tokens
```markdown
‚úÖ ELEVATION TOKEN REQUIREMENTS
‚ñ° Elevation scale (0-24 levels for Material Design)
‚ñ° Shadow definitions for each elevation level
‚ñ° Platform-specific elevation (iOS shadows vs Android elevation)
‚ñ° Dark mode shadow adaptations
‚ñ° Performance-optimized shadow implementations
‚ñ° Accessibility considerations (sufficient contrast for shadows)
```

### Design Token Implementation Protocol
```markdown
üîÑ DESIGN TOKEN WORKFLOW
1. Define base tokens (primitive values)
2. Create semantic tokens (purpose-based aliases)
3. Implement platform-specific token variations
4. Validate accessibility compliance for all tokens
5. Test tokens across different themes and modes
6. Document token usage guidelines and examples
7. Create token validation and testing protocols
```

## ‚öõÔ∏è ATOMS (BASIC UI ELEMENTS)

### Atom Categories and Requirements
Atoms are the basic building blocks of the interface, built using design tokens:

#### Input Atoms
```markdown
‚úÖ INPUT ATOM REQUIREMENTS
‚ñ° Text inputs with all states (default, focus, error, disabled)
‚ñ° Checkbox and radio button components
‚ñ° Toggle switches with platform-appropriate styling
‚ñ° Slider components with accessibility support
‚ñ° File upload components with drag-and-drop
‚ñ° Search input with clear and submit actions
‚ñ° All inputs meet minimum touch target requirements (44pt/48dp)
‚ñ° Proper ARIA labeling and keyboard navigation
‚ñ° Error state handling with clear messaging
‚ñ° Platform-specific styling (iOS vs Android vs Web)
```

#### Button Atoms
```markdown
‚úÖ BUTTON ATOM REQUIREMENTS
‚ñ° Primary, secondary, and tertiary button variants
‚ñ° Icon buttons with proper accessibility labels
‚ñ° Floating action buttons (mobile platforms)
‚ñ° Link buttons with proper focus indicators
‚ñ° All button states (default, hover, active, disabled, loading)
‚ñ° Minimum touch target size with proper spacing
‚ñ° Keyboard navigation and activation support
‚ñ° Screen reader compatibility with proper announcements
‚ñ° Platform-specific button styling and behavior
‚ñ° Loading states with appropriate feedback
```

#### Display Atoms
```markdown
‚úÖ DISPLAY ATOM REQUIREMENTS
‚ñ° Typography components (headings, body text, captions)
‚ñ° Icon components with accessibility support
‚ñ° Avatar components with fallback states
‚ñ° Badge and tag components
‚ñ° Divider and separator components
‚ñ° Loading indicators (spinners, progress bars)
‚ñ° All components responsive across breakpoints
‚ñ° Proper semantic HTML structure
‚ñ° Screen reader optimization
‚ñ° High contrast mode support
```

### Atom Design Protocol
```markdown
üîÑ ATOM DESIGN WORKFLOW
1. Start with design token foundation
2. Design basic visual appearance
3. Define all interactive states
4. Implement responsive behavior
5. Add accessibility features (ARIA, keyboard support)
6. Test across platforms and devices
7. Document component API and usage guidelines
8. Validate against design system standards
```

## üß¨ MOLECULES (SIMPLE COMPONENT GROUPS)

### Molecule Categories and Requirements
Molecules combine atoms to create functional UI components:

#### Form Molecules
```markdown
‚úÖ FORM MOLECULE REQUIREMENTS
‚ñ° Form field groups (label + input + help text + error message)
‚ñ° Search bars with input, icon, and clear functionality
‚ñ° Login forms with username, password, and submit
‚ñ° Filter groups with multiple input types
‚ñ° Address forms with proper field grouping
‚ñ° All molecules maintain atom accessibility features
‚ñ° Proper form validation and error handling
‚ñ° Responsive layout adaptation
‚ñ° Platform-specific form patterns
‚ñ° Keyboard navigation between form elements
```

#### Navigation Molecules
```markdown
‚úÖ NAVIGATION MOLECULE REQUIREMENTS
‚ñ° Breadcrumb navigation with proper hierarchy
‚ñ° Pagination components with accessibility
‚ñ° Tab navigation with proper ARIA implementation
‚ñ° Menu items with icons and labels
‚ñ° Navigation links with active states
‚ñ° All navigation accessible via keyboard
‚ñ° Screen reader navigation support
‚ñ° Responsive navigation patterns
‚ñ° Platform-specific navigation conventions
‚ñ° Focus management and indication
```

#### Content Molecules
```markdown
‚úÖ CONTENT MOLECULE REQUIREMENTS
‚ñ° Card headers with title, subtitle, and actions
‚ñ° Media objects with image and text content
‚ñ° List items with various content types
‚ñ° Notification components with dismiss functionality
‚ñ° Tooltip components with proper positioning
‚ñ° All content accessible and semantic
‚ñ° Responsive content adaptation
‚ñ° Proper heading hierarchy
‚ñ° Screen reader optimization
‚ñ° Touch-friendly interaction areas
```

### Molecule Design Protocol
```markdown
üîÑ MOLECULE DESIGN WORKFLOW
1. Identify required atoms for the molecule
2. Design composition and layout
3. Define interaction patterns and states
4. Implement responsive behavior
5. Ensure accessibility compliance
6. Test component combinations
7. Document molecule API and usage
8. Validate against design system patterns
```

## ü¶† ORGANISMS (COMPLEX UI SECTIONS)

### Organism Categories and Requirements
Organisms are complex UI components that combine molecules and atoms:

#### Navigation Organisms
```markdown
‚úÖ NAVIGATION ORGANISM REQUIREMENTS
‚ñ° Header navigation with logo, menu, and user actions
‚ñ° Sidebar navigation with hierarchical menu structure
‚ñ° Footer navigation with links and information
‚ñ° Mobile navigation with hamburger menu and drawer
‚ñ° Breadcrumb navigation with proper hierarchy
‚ñ° All navigation organisms fully accessible
‚ñ° Responsive navigation patterns
‚ñ° Keyboard navigation support
‚ñ° Screen reader navigation landmarks
‚ñ° Focus management across navigation elements
```

#### Content Organisms
```markdown
‚úÖ CONTENT ORGANISM REQUIREMENTS
‚ñ° Article layouts with header, content, and metadata
‚ñ° Card grids with responsive layout
‚ñ° Data tables with sorting, filtering, and pagination
‚ñ° Form sections with grouped fields and validation
‚ñ° Comment sections with threading and actions
‚ñ° All content organisms semantically structured
‚ñ° Responsive layout adaptation
‚ñ° Accessibility compliance (landmarks, headings)
‚ñ° Keyboard navigation support
‚ñ° Screen reader optimization
```

#### Interactive Organisms
```markdown
‚úÖ INTERACTIVE ORGANISM REQUIREMENTS
‚ñ° Modal dialogs with proper focus management
‚ñ° Dropdown menus with keyboard navigation
‚ñ° Accordion components with expand/collapse
‚ñ° Carousel components with accessibility controls
‚ñ° Dashboard widgets with data visualization
‚ñ° All interactive organisms accessible
‚ñ° Proper focus management and trapping
‚ñ° Keyboard interaction support
‚ñ° Screen reader announcements
‚ñ° Touch gesture support (mobile)
```

### Organism Design Protocol
```markdown
üîÑ ORGANISM DESIGN WORKFLOW
1. Analyze required molecules and atoms
2. Design overall layout and structure
3. Define complex interaction patterns
4. Implement advanced responsive behavior
5. Ensure comprehensive accessibility
6. Test organism in various contexts
7. Document organism API and integration
8. Validate against user experience requirements
```

## üìã TEMPLATES (PAGE-LEVEL STRUCTURES)

### Template Categories and Requirements
Templates define page-level layout structures without specific content:

#### Layout Templates
```markdown
‚úÖ LAYOUT TEMPLATE REQUIREMENTS
‚ñ° Single-column layouts for mobile and simple content
‚ñ° Two-column layouts with sidebar and main content
‚ñ° Three-column layouts for complex information architecture
‚ñ° Dashboard layouts with widget areas and navigation
‚ñ° Landing page layouts with hero, features, and footer
‚ñ° All templates responsive across all breakpoints
‚ñ° Proper semantic structure (header, main, aside, footer)
‚ñ° Accessibility landmarks and navigation
‚ñ° Flexible content areas for various content types
‚ñ° Platform-specific layout adaptations
```

#### Modal and Overlay Templates
```markdown
‚úÖ MODAL TEMPLATE REQUIREMENTS
‚ñ° Dialog templates with header, content, and actions
‚ñ° Drawer templates for mobile navigation
‚ñ° Popover templates for contextual information
‚ñ° Full-screen overlay templates
‚ñ° Sheet templates for mobile bottom sheets
‚ñ° All modal templates with proper focus management
‚ñ° Escape key and backdrop click handling
‚ñ° Screen reader announcements
‚ñ° Responsive modal behavior
‚ñ° Platform-specific modal patterns
```

#### Specialized Templates
```markdown
‚úÖ SPECIALIZED TEMPLATE REQUIREMENTS
‚ñ° Form templates with multi-step flows
‚ñ° E-commerce templates with product layouts
‚ñ° Blog templates with article structure
‚ñ° Dashboard templates with data visualization areas
‚ñ° Error page templates with recovery actions
‚ñ° All templates semantically structured
‚ñ° Responsive layout adaptation
‚ñ° Accessibility compliance
‚ñ° SEO optimization (web platforms)
‚ñ° Performance optimization
```

### Template Design Protocol
```markdown
üîÑ TEMPLATE DESIGN WORKFLOW
1. Define page structure and layout requirements
2. Identify required organisms and their placement
3. Design responsive layout behavior
4. Implement accessibility structure (landmarks, headings)
5. Test template with various content types
6. Validate responsive behavior across devices
7. Document template usage and customization
8. Ensure performance optimization
```

## üìÑ PAGES (COMPLETE USER INTERFACES)

### Page Categories and Requirements
Pages are complete user interfaces that apply templates with real content:

#### Application Pages
```markdown
‚úÖ APPLICATION PAGE REQUIREMENTS
‚ñ° Dashboard pages with real data and interactions
‚ñ° Profile pages with user information and settings
‚ñ° Settings pages with configuration options
‚ñ° Search results pages with filtering and sorting
‚ñ° Detail pages with comprehensive information
‚ñ° All pages fully functional and accessible
‚ñ° Complete user task flows
‚ñ° Error handling and edge cases
‚ñ° Performance optimization
‚ñ° SEO optimization (web platforms)
```

#### Marketing Pages
```markdown
‚úÖ MARKETING PAGE REQUIREMENTS
‚ñ° Landing pages with compelling content and CTAs
‚ñ° Product pages with features and benefits
‚ñ° Pricing pages with comparison tables
‚ñ° About pages with team and company information
‚ñ° Contact pages with forms and information
‚ñ° All pages optimized for conversion
‚ñ° Responsive design across all devices
‚ñ° Accessibility compliance
‚ñ° SEO optimization
‚ñ° Performance optimization
```

#### Utility Pages
```markdown
‚úÖ UTILITY PAGE REQUIREMENTS
‚ñ° Login and registration pages
‚ñ° Error pages (404, 500, etc.) with recovery options
‚ñ° Loading pages with progress indicators
‚ñ° Maintenance pages with status information
‚ñ° Privacy policy and terms of service pages
‚ñ° All pages accessible and functional
‚ñ° Proper error handling
‚ñ° Clear user guidance
‚ñ° Responsive design
‚ñ° Performance optimization
```

### Page Design Protocol
```markdown
üîÑ PAGE DESIGN WORKFLOW
1. Apply appropriate template structure
2. Populate with real content and data
3. Implement complete user interactions
4. Test full user task flows
5. Validate accessibility with real content
6. Optimize performance with actual data
7. Test across all target devices and platforms
8. Document page specifications and requirements
```

## üîÑ ATOMIC DESIGN INTEGRATION PROTOCOLS

### Cross-Level Consistency
```markdown
‚úÖ ATOMIC DESIGN CONSISTENCY REQUIREMENTS
‚ñ° Design tokens used consistently across all levels
‚ñ° Component APIs follow consistent patterns
‚ñ° Accessibility implementation consistent throughout
‚ñ° Responsive behavior coherent across components
‚ñ° Performance optimization applied at all levels
‚ñ° Documentation standards maintained across levels
‚ñ° Testing protocols applied consistently
‚ñ° Platform adaptations coordinated across levels
```

### Component Dependency Management
```markdown
‚úÖ DEPENDENCY MANAGEMENT REQUIREMENTS
‚ñ° Clear dependency hierarchy documented
‚ñ° Version compatibility maintained across levels
‚ñ° Breaking changes managed with migration guides
‚ñ° Component composition patterns documented
‚ñ° Reusability maximized through proper abstraction
‚ñ° Performance impact of dependencies monitored
‚ñ° Accessibility inheritance properly implemented
‚ñ° Platform-specific dependencies clearly identified
```

### Validation and Testing Protocols
```markdown
‚úÖ ATOMIC DESIGN VALIDATION REQUIREMENTS
‚ñ° Unit testing for individual atoms
‚ñ° Integration testing for molecules and organisms
‚ñ° Visual regression testing across all levels
‚ñ° Accessibility testing with assistive technology
‚ñ° Performance testing for component combinations
‚ñ° Cross-platform testing for all components
‚ñ° User testing with complete page implementations
‚ñ° Documentation accuracy validation
```

## üö® ATOMIC DESIGN ERROR PREVENTION

### Common Atomic Design Pitfalls
```markdown
‚ùå ATOMIC DESIGN ANTI-PATTERNS TO AVOID
‚ñ° Skipping design token foundation
‚ñ° Creating atoms that are too complex
‚ñ° Molecules that don't compose properly
‚ñ° Organisms that are too tightly coupled
‚ñ° Templates that are too rigid or too flexible
‚ñ° Pages that don't follow template structure
‚ñ° Inconsistent component APIs across levels
‚ñ° Poor accessibility implementation inheritance
‚ñ° Inadequate responsive behavior coordination
‚ñ° Performance issues from component composition
```

### Recovery and Remediation Strategies
```markdown
üîß ATOMIC DESIGN RECOVERY PROTOCOLS
‚ñ° Design token audit and standardization
‚ñ° Component complexity analysis and refactoring
‚ñ° API consistency review and standardization
‚ñ° Accessibility audit across all levels
‚ñ° Performance optimization review
‚ñ° Documentation update and validation
‚ñ° Testing protocol implementation
‚ñ° User feedback integration and iteration
```

---

**Remember**: Atomic design methodology ensures systematic, scalable, and maintainable component development. Every level builds upon the previous one while maintaining consistency, accessibility, and performance across the entire design system.